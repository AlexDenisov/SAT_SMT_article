\subsection{Символьные вычисления}

Начнем с символьных вычислений\footnote{\url{https://en.wikipedia.org/wiki/Symbolic_computation}}.

Некоторые числа могут быть представлены в двоичной системе только в некотором приближении, как $\frac{1}{3}$ и $\pi$.
Если вычислять $\frac{1}{3} \cdot 3$ пошагово, мы можем получить потерю значимости.
Мы также знаем, что $sin(\frac{\pi}{2}) = 1$, но вычисляя это выражение обычным образом, мы также получим шум в результате.
Арифметика произвольной точности (arbitrary-precision arithmetic)\footnote{\url{https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic}} это не решение, потому что эти числа не могут быть представлены в памяти 
как двоичное число конечной длины.

Как можно решить эту проблему?
Люди сокращают подобные выражения используя бумагу и карандаш без всяких вычислений.
Мы можем имитировать человеческое поведение программно если мы будем сохранять выражение как дерево,
а символы вроде $\pi$ будут конвертироваться в числа на самом последнем шаге.

Это то что делает Wolfram Mathematica\footnote{Другие хорошо известные системы символьной математики это 
\href{https://en.wikipedia.org/wiki/Maxima_\%28software\%29}{Maxima} и 
\href{https://en.wikipedia.org/wiki/SymPy}{SymPy}}.
Запустим и попробуем это:

\begin{lstlisting}
In[]:= x + 2*8
Out[]= 16 + x
\end{lstlisting}

Так как Mathematica не имеет понятия что такое $x$, оно оставляется \textit{как есть}, но $2 \cdot 8$ можно легко
сократить, это может сделать и Mathematica и человек, вот это и произошло.
В какой-то момент в будущем, пользователь Mathematica может присвоить какое-то число переменной
$x$ и затем Mathematica сократит это выражение дальше.

Mathematica делает это потому что она парсит выражение и находит некоторые известные ей шаблонные правила.
Это также называется \textit{переписывание термов (term rewriting)}\footnote{\url{https://en.wikipedia.org/wiki/Rewriting}}.
В обычном русском языке это может звучать так:
``если там где-то есть оператор $+$ между двумя известными числами,
замени это подвыражение на вычисленное число, которое является
суммой этих двух чисел, если это возможно''.
Точно также, как это делают люди.

Mathematica также имеет правила вроде ``замени $sin(\pi)$ на 0'' и ``замени $sin(\frac{\pi}{2})$ на 1'', но как вы видите,
$\pi$ должно быть сохранено как что-то вроде символа, вместо числа.

% TODO example
Так что Mathematica оставила $x$ как неизвестное значение.
Кстати, это распространенная ошибка пользователей Mathematica: мелкая опечатка во входном выражении может привести к
огромному несократимому выражению, в котором остается эта же опечатка.

Другой пример: Mathematica сознательно оставляет это во время вычисления двоичного логарифма:

\begin{lstlisting}
In[]:= Log[2, 36]
Out[]= Log[36]/Log[2]
\end{lstlisting}

Потому что она имеет надежду что в какой-то момент времени, в будущем, это выражение станет подвыражением другого
выражения, и оно будет красиво сокращено в самом конце.
Но если нам действительно нужен целочисленный ответ, мы можем заставить Mathematica вычислить его:

\begin{lstlisting}
In[]:= Log[2, 36] // N
Out[]= 5.16993
\end{lstlisting}

Иногда значения, как невычисленные символы, желательны:

\begin{lstlisting}
In[]:= Union[{a, b, a, c}, {d, a, e, b}, {c, a}]
Out[]= {a, b, c, d, e}
\end{lstlisting}

Символы в выражении это просто невычисленные символы\footnote{\textit{Символ} как в LISP} без привязки
к числам или другим выражениям, так что Mathematica оставила их \textit{как есть}.

Другой пример из реального мира это символьная интеграция\footnote{\url{https://en.wikipedia.org/wiki/Symbolic_integration}}, 
т.е., нахожение формулы интеграла путем переписывания изначального выражения используя некоторые предопределенные правила.
Mathematica тоже делает это:

\begin{lstlisting}
In[]:= Integrate[1/(x^5), x]
Out[]= -(1/(4 x^4))
\end{lstlisting}

Преимущества символьных вычислений очевидны: нет проблем с \textit{loss of significance}\footnote{\url{https://en.wikipedia.org/wiki/Loss_of_significance}} и ошибок округления\footnote{\url{https://en.wikipedia.org/wiki/Round-off_error}}, 
но недостатки тоже очевидны: вам нужно хранить где-то дерево выражения (возможно, огромное), и обрабатывать его много раз.
Переписывание термов может быть медленным.
Все эти вещи очень неуклюжи в сравнении с быстрым \ac{FPU}.

``Символьные вычисления'' противопоставляются ``численным вычислениям'', последнее это просто обработка чисел шаг за шагом,
используя калькулятор, \ac{CPU} или \ac{FPU}.\\
\\
Некоторые задачи лучше решать первым методом, некоторые другие --- вторым.

\subsubsection{Дробный (rational) тип данных}

Некоторые реализации LISP-а могут хранить число как дробь
\footnote{\url{https://en.wikipedia.org/wiki/Rational_data_type}}, т.е., храня два числа в ячейке (которая, в данном случае, называется \textit{атомом} на сленге LISP-а).
Например, если вы делите 1 на 3, и интерпретатор, понимая что $\frac{1}{3}$ это
несократимая дробь\footnote{\url{http://bit.ly/2pXhzpy}}, создает ячейку с числами 1 и 3.
В какой-то момент позже, вы можете умножить эту ячейку на 6, и умножающая ф-ция внутри интерпретатора LISP-а может вернуть
намного лучший результат (2 без \textit{шума}).

Печатающая ф-ция в интерпретаторе может вывести что-то вроде \TT{1 / 3} вместо числа с плавающей точкой.

Иногда это называется ``fractional arithmetic'' [см. Donald E. Knuth, \textit{The Art of Computing Programming}, 3-е изд., (1997), 4.5.1, стр.330].

Это не символьные вычисления ни в каком смысле, но это немного лучше чем хранить дроби как обычные числа с плавающей точкой.

Недостатки очевидны: вам нужно больше памяти чтобы хранить дробь вместо числа;
и все арифметические ф-ции более сложные и медленные, потому что они должны поддерживать и числа и дроби.

Вероятно, из-за недостатков, некоторые языки программирования предлагают отдельный тип данных (\textit{rational}),
как опцию языка, или как поддержку библиотекой
\footnote{Более полный список: \url{https://en.wikipedia.org/wiki/Rational_data_type}}:
Haskell, OCaml, Perl, Ruby, Python (\textit{fractions}), Smalltalk, Java, Clojure, C/C++
\footnote{При помощи GNU Multiple Precision Arithmetic Library}.

