\subsection{Пример: простая хэш-функция}

(Этот текст был впервые добавлен в мою книгу ``Reverse Engineering для начинающих'' (\url{beginners.re}) в марте 2014
\footnote{Этот пример также использовался Murphy Berzish в его лекции о \ac{SAT} и \ac{SMT}:
\url{http://mirror.csclub.uwaterloo.ca/csclub/mtrberzi-sat-smt-slides.pdf},
\url{http://mirror.csclub.uwaterloo.ca/csclub/mtrberzi-sat-smt.mp4}}.)

Вот необратимая хэш-функция, которая конвертирует одно 64-битное значение в другое,
и нам нужно попытаться развернуть её работу назад.

\subsubsection{Ручная декомпиляция}

Вот листинг на ассемблере в IDA:

\lstinputlisting{crypto/hash/algo_1.asm}

Пример был скомпилирован в GCC, so the first argument is passed in ECX.

Если вы не имеете Hex-Rays, либо вы не доверяете его результатам, мы можем попробовать
переписать всё это на Си вручную.
Один из методов, это представить регистры \ac{CPU} в виде локальных переменных Си и заменить каждую инструкцию
эквивалентным выражением, например:

\lstinputlisting{crypto/hash/algo_2.c}

Если быть достаточно аккуратным, этот код можно скомпилировать, и он даже будет работать, 
точно так же, как оригинальный.

Затем, будем переписывать его постепенно, не забывая об использовании регистров.
Внимание и фокусирование здесь крайне важно --- любая самая мелкая опечатка может испортить всю работу!

Первый шаг:

\lstinputlisting{crypto/hash/algo_3.c}

Следующий шаг:

\lstinputlisting{crypto/hash/algo_4.c}


Мы находим деление через умножение.
Действительно, найдем делитель в Wolfram Mathematica:

\begin{lstlisting}[caption=Wolfram Mathematica]
In[1]:=N[2^(64 + 5)/16^^8888888888888889]
Out[1]:=60.
\end{lstlisting}

Получаем:

\lstinputlisting{crypto/hash/algo_5.c}

Еще один шаг:

\lstinputlisting{crypto/hash/algo_6.c}

Простым сокращением, мы видим, что вычислялось вовсе не частное, а остаток от деления:

\lstinputlisting{crypto/hash/algo_7.c}

Заканчиваем на приятно отформатированном исходном коде:

\lstinputlisting{crypto/hash/algo_src.c}

Так как мы не криптоаналитики, мы не можем найти простой способ найти входное значение
для определенного выходного значения.
Коэффициенты инструкций сдвигов выглядят очень пугающе --- это гарантия что функция не биективная,
она скорее сюръективная,
она имеет коллизии, или, говоря проще, возможны несколько значений на входе для одного на выходе.

Брут-форс это тоже не решение, т.к., значения 64-битные, и это совершенно нереально.

\subsubsection{Попробуем Z3}

Но все же, без всяких специальных знаний из криптографии, мы можем попытаться взломать алгоритм при помощи Z3.

Вот исходный код на Питоне:

\lstinputlisting[numbers=left]{crypto/hash/1.py}

Это будет наш первый солвер.

На строке 7 мы видим объявление переменных.
Это просто 64-битные переменные.
\TT{i1..i6} это промежуточные переменные, отражающие значения в регистрах между исполнениями инструкций.

Потом добавляем т.н. констрайнты, в строках 10..15.
Самый последний констрайнт в строке 17 это наиболее важный: мы будем искать входное значение для
нашего алгоритма, при котором он выдаст на выходе 10816636949158156260.

\textit{RotateRight, RotateLeft, URem} --- это функции из Питоновского Z3 \ac{API} для описания выражений, 
они не связаны с ЯП Python.

Запускаем:

\begin{lstlisting}
...>python.exe 1.py
sat
[i1 = 3959740824832824396,
 i3 = 8957124831728646493,
 i5 = 10816636949158156260,
 inp = 1364123924608584563,
 outp = 10816636949158156260,
 i4 = 14065440378185297801,
 i2 = 4954926323707358301]
 inp=0x12EE577B63E80B73
outp=0x961C69FF0AEFD7E4
\end{lstlisting}

``sat'' означает ``satisfiable'', т.е. солвер нашел по крайней мере одно решение.
Решение выведено внутри квадратных скобок.
Две последние строки это пара входного/выходного значения в шестнадцатеричном виде.
Да, действительно, если мы запустим нашу функцию с
\TT{0x12EE577B63E80B73} на входе, алгоритм выдаст искомое значение.

Но, как мы заметили ранее, функция не биективная, так что тут могут быть и другие корректные входные значения.
Z3 SMT-солвер не выдает результаты больше одного, но мы можем хакнуть наш пример немного, 
добавив констрайнт в строке 19, означая, что мы ищем какие угодно другие результаты кроме этого:

\lstinputlisting[numbers=left]{crypto/hash/2.py}

Действительно, получаем еще один верный результат:

\begin{lstlisting}
...>python.exe 2.py
sat
[i1 = 3959740824832824396,
 i3 = 8957124831728646493,
 i5 = 10816636949158156260,
 inp = 10587495961463360371,
 outp = 10816636949158156260,
 i4 = 14065440378185297801,
 i2 = 4954926323707358301]
 inp=0x92EE577B63E80B73
outp=0x961C69FF0AEFD7E4
\end{lstlisting}

Это можно автоматизировать.
Каждый найденный результат можно добавлять в качестве констрайнта и искать следующий.
Пример немного сложнее:

\lstinputlisting[numbers=left]{crypto/hash/3.py}

Получаем:

\begin{lstlisting}
1364123924608584563
1234567890
9223372038089343698
4611686019661955794
13835058056516731602
3096040143925676201
12319412180780452009
7707726162353064105
16931098199207839913
1906652839273745429
11130024876128521237
15741710894555909141
6518338857701133333
5975809943035972467
15199181979890748275
10587495961463360371
results total= 16
\end{lstlisting}

Так что имеется 16 верных входных значений для \TT{0x92EE577B63E80B73} на выходе.

Второй это 1234567890 --- действительно, это значение было использовано изначально,
при подготовке этого примера.

Попробуем изучить алгоритм немного больше.
В порыве садистских желаний, попробуем найти, есть ли здесь какая-нибудь возможная пара входов/выходов,
в которых младшие 32-битные части равны друг другу?

Уберем констрайнт \textit{outp} и добавим другой, в строке 17:

\lstinputlisting[numbers=left]{crypto/hash/4.py}

И действительно:

\begin{lstlisting}
sat
[i1 = 14869545517796235860,
 i3 = 8388171335828825253,
 i5 = 6918262285561543945,
 inp = 1370377541658871093,
 outp = 14543180351754208565,
 i4 = 10167065714588685486,
 i2 = 5541032613289652645]
 inp=0x13048F1D12C00535
outp=0xC9D3C17A12C00535
\end{lstlisting}

Можем упражняться в садизме и далее: пусть последние 16-бит всегда будут \TT{0x1234}:

\lstinputlisting[numbers=left]{crypto/hash/5.py}

Это так же возможно:

\begin{lstlisting}
sat
[i1 = 2834222860503985872,
 i3 = 2294680776671411152,
 i5 = 17492621421353821227,
 inp = 461881484695179828,
 outp = 419247225543463476,
 i4 = 2294680776671411152,
 i2 = 2834222860503985872]
 inp=0x668EEC35F961234
outp=0x5D177215F961234
\end{lstlisting}

Z3 работает крайне быстро и это означает что алгоритм слаб, и вообще не относится к криптографическим 
(как и почти вся любительская криптография).

